[{"content":"Welcome to 2026! üéâ As the clock strikes midnight and we enter a new year, I feel filled with gratitude, excitement and anticipation for what lies ahead. Welcome to 2026 - a fresh chapter, a blank canvas, and many opportunities to learn, grow, share and connect.\nReflecting on 2025 Looking back at 2025, it\u0026rsquo;s been an incredible journey of growth, learning, and transformation. This past year has taught me valuable lessons:\nContinuous Learning: Technology never stops evolving, and neither should we. AI is a part of our daily working, it\u0026rsquo;s not just a tool for developers, it\u0026rsquo;s a tool for everyone. You can use ChapGPT for learning, explaining about the topic, lesson, etc. Gemini for generate images, videos, content, etc. Claude and Copilot for code and debugging, etc. Community Matters: The connections we build, the knowledge we share, and the support we give each other make all the difference. Resilience: Not every project goes as planned, not every bug gets fixed on the first try, but persistence always pays off. Balance: Finding harmony between coding, learning, and life is essential for long-term success and happiness. Achievement: I have completed 5/7 of my goals for 2025. For me, it was hard work, luck, and especially the support from my family, friends and co-workers. I\u0026rsquo;m grateful for every reader who visited this blog, every developer who shared their insights, and every challenge that pushed me to become better.\nWhat 2026 Holds As I enter this new year, I\u0026rsquo;m setting intentions rather than rigid resolutions. Here\u0026rsquo;s what I\u0026rsquo;m excited to explore and share with you:\nüöÄ Technical Deep Dives I\u0026rsquo;ll be diving deeper into cutting-edge technologies, distributed systems, cloud architecture, and modern development practices. Expect detailed tutorials, real-world case studies, and practical insights you can apply immediately.\nüí° Problem-Solving Chronicles I\u0026rsquo;ll document my journey tackling complex technical challenges - the successes, the failures, and everything in between. Real problems, real solutions, real learning.\nüå± Growth \u0026amp; Learning From mastering new programming languages to exploring AI/ML, from system design to performance optimization - I\u0026rsquo;ll share my learning path so we can grow together.\nü§ù Community Engagement More interactive content, discussions, and opportunities to connect. Your feedback shapes this blog, and I want to hear more from you in 2026.\nA Message for You If you\u0026rsquo;re reading this, whether you\u0026rsquo;re a seasoned developer or just starting your coding journey, I want you to know:\nYou are capable of amazing things.\n2026 is your year to:\nBuild that project you\u0026rsquo;ve been thinking about Learn that technology that intimidates you Contribute to open source Share your knowledge with others Take that career leap you\u0026rsquo;ve been contemplating Don\u0026rsquo;t let fear of failure hold you back. Every expert was once a beginner. Every successful project started with a single line of code. Every breakthrough came after countless attempts.\nLet\u0026rsquo;s Make It Count This year, I\u0026rsquo;m committing to:\n‚úÖ Consistency - Regular, high-quality content that adds value\n‚úÖ Authenticity - Sharing real experiences, including the messy parts\n‚úÖ Community - Building connections and learning together\n‚úÖ Excellence - Pushing boundaries and never settling for \u0026ldquo;good enough\u0026rdquo;\nI invite you to join me on this journey. Let\u0026rsquo;s make 2026 a year of growth, innovation, and meaningful impact.\nWhat\u0026rsquo;s Coming Next In the upcoming posts, you can expect:\nDeep technical tutorials on modern development practices System design insights from real-world applications Performance optimization techniques and case studies Career development tips and lessons learned Tool reviews and productivity hacks Industry trends and emerging technologies Stay tuned, stay curious, and stay passionate about what you do.\nFinal Thoughts As we stand at the threshold of 2026, remember that every day is a new opportunity to learn, create, and grow. The journey of a thousand miles begins with a single step, and today is the perfect day to take that step.\nHere\u0026rsquo;s to new challenges, new victories, and new friendships. Here\u0026rsquo;s to the code we\u0026rsquo;ll write, the problems we\u0026rsquo;ll solve, and the impact we\u0026rsquo;ll make.\nWelcome to 2026. Let\u0026rsquo;s make it extraordinary together! üöÄ\nWhat are your goals for 2026? What technologies are you excited to explore? Drop a comment below - I\u0026rsquo;d love to hear from you!\n","date":"2026-01-02T10:55:00+07:00","image":"https://quanghugo.pages.dev/p/hi-2026/cover_hu_dab444542f204b1b.png","permalink":"https://quanghugo.pages.dev/p/hi-2026/","title":"Hi 2026"},{"content":"The Problem (Quick Recap) In our previous article, I explored a critical issue: when servers restart during deployment, in-memory timeout timers are lost, causing orders to get stuck in pending status indefinitely.\nThe scenario: A customer places an order and the system starts a 60s timer. If payment isn\u0026rsquo;t confirmed within 60s, the order should automatically timeout. But if the server restarts at second 45, that timer disappears‚Äîand the order never times out. The customer sees \u0026ldquo;Order failed\u0026rdquo; on their screen, but the backend still thinks the order is PENDING.\nThis creates confusion, duplicate orders, and requires manual cleanup.\nThe Core Insight The problem isn\u0026rsquo;t with timers themselves‚Äîit\u0026rsquo;s where I store the timer information. When I store timeout information in the application\u0026rsquo;s memory, it disappears when the application restarts.\nThe solution? Move timeout tracking outside the application into a shared storage system that survives restarts.\nThe Calendar Analogy Imagine two ways of tracking deadlines:\nOld Approach (In-Memory Timer)\nEach employee has a desk calendar. When they mark \u0026ldquo;Review document by 3 PM,\u0026rdquo; only they know about it. If they go home sick, no one else can see that deadline‚Äîit\u0026rsquo;s lost.\nNew Approach (Shared Storage)\nThe team uses a shared wall calendar in the office. When anyone marks \u0026ldquo;Review document by 3 PM,\u0026rdquo; everyone can see it. If one person is unavailable, someone else can check the calendar and handle the task.\nThis is exactly what I\u0026rsquo;m doing: moving from individual \u0026ldquo;desk calendars\u0026rdquo; (in-memory timers) to a \u0026ldquo;shared wall calendar\u0026rdquo; (Redis) that all servers can access.\nThe Solution: Three Key Components Our solution uses three simple concepts that work together:\n1. The Shared Timeout List What it is: A shared list where I writes down every timeout and when it should happen, sorted by time.\nHow it works: When an order is created, instead of setting a timer in the server\u0026rsquo;s memory, I write to this shared list: \u0026ldquo;Order #12345 should timeout at 2:30:15 PM.\u0026rdquo;\nWhy it survives restarts: This list lives in a database-like storage system (Redis) that\u0026rsquo;s separate from our application servers. When a server restarts, the list is still there, untouched.\nAnalogy: Like a shared to-do list on the wall, sorted by deadline. Everyone can see it, and it doesn\u0026rsquo;t disappear when someone leaves the room.\n2. The Worker Pattern What it is: Every server regularly checks the shared timeout list to find tasks that are ready to be processed.\nHow it works: Every second, each server asks: \u0026ldquo;Are there any timeouts in the list that have already passed?\u0026rdquo; If it finds any, it processes them.\nWhy it\u0026rsquo;s resilient: If one server goes down, the other servers keep checking the list. No single server is responsible for any specific timeout‚Äîthey all share the work.\nAnalogy: Like multiple security guards on patrol. They all check the same checklist every few minutes. If one guard goes on break, the others keep checking‚Äînothing gets missed.\n3. The Lock (Preventing Duplicates) What it is: A mechanism to ensure only one server processes each timeout, even though multiple servers are checking the list.\nHow it works: When Server A sees an expired timeout, it tries to \u0026ldquo;grab\u0026rdquo; it by placing a lock. If it succeeds, it processes the timeout. If Server B tries to grab the same timeout a moment later, it sees the lock and skips it‚Äîknowing Server A is already handling it.\nWhy it\u0026rsquo;s necessary: Without locks, Server A and Server B might both process the same timeout, sending two \u0026ldquo;Order timed out\u0026rdquo; notifications to the customer.\nAnalogy: Like task cards on a Kanban board. When you start working on a task, you move the card to \u0026ldquo;In Progress\u0026rdquo;.Other team members see it\u0026rsquo;s being worked on and don\u0026rsquo;t duplicate the effort.\nHow It All Works Together Let\u0026rsquo;s walk through a complete timeout lifecycle:\nflowchart TB Order[Customer Places Order] Write[Write to Shared List:\u0026lt;br/\u0026gt;Order 12345 timeout at 2:30 PM] SharedList[(Shared Timeout List\u0026lt;br/\u0026gt;in Redis)] Order --\u0026gt; Write Write --\u0026gt; SharedList subgraph AllServers[All Servers Working Together] ServerA[Server A checks list\u0026lt;br/\u0026gt;every second] ServerB[Server B checks list\u0026lt;br/\u0026gt;every second] ServerC[Server C checks list\u0026lt;br/\u0026gt;every second] end SharedList -.-\u0026gt;|poll| ServerA SharedList -.-\u0026gt;|poll| ServerB SharedList -.-\u0026gt;|poll| ServerC ServerA --\u0026gt; FindExpired[Found expired timeout:\u0026lt;br/\u0026gt;Order 12345] FindExpired --\u0026gt; TryLock{Try to lock\u0026lt;br/\u0026gt;Order 12345} TryLock --\u0026gt;|Lock successful| Process[Process timeout:\u0026lt;br/\u0026gt;Update order status\u0026lt;br/\u0026gt;Notify customer] TryLock --\u0026gt;|Lock failed| Skip[Skip - another\u0026lt;br/\u0026gt;server handling it] Process --\u0026gt; RemoveFromList[Remove from shared list] Step-by-step explanation:\nOrder Created: Customer places Order #12345. The system writes to the shared list: \u0026ldquo;Order #12345, timeout at 2:30:15 PM\u0026rdquo;\nServers Monitor: All servers (A, B, C) independently check the shared list every second, asking \u0026ldquo;Any timeouts past their deadline?\u0026rdquo;\nTimeout Found: At 2:30:16 PM, Server A checks and finds Order #12345 is past its deadline (by 1 second)\nLock Attempt: Server A tries to \u0026ldquo;lock\u0026rdquo; Order #12345. If successful, it proceeds. If another server locked it first, Server A skips it.\nProcess Timeout: Server A updates the order status to \u0026ldquo;Payment Timeout\u0026rdquo; and sends a notification to the customer\nClean Up: Server A removes Order #12345 from the shared list so no other server tries to process it\nWhat Happens During Deployment This is where the new approach really shines. Let\u0026rsquo;s compare the old and new systems during a rolling deployment:\nOld System: In-Memory Timer sequenceDiagram participant Customer participant ServerA participant Kubernetes participant Database Customer-\u0026gt;\u0026gt;ServerA: Place order ServerA-\u0026gt;\u0026gt;Database: Save order (Pending) ServerA-\u0026gt;\u0026gt;ServerA: Start 60s timer\u0026lt;br/\u0026gt;in memory Note over ServerA: Timer counting: 45s...44s...43s... Kubernetes-\u0026gt;\u0026gt;ServerA: Deploy new version\u0026lt;br/\u0026gt;(restart server) ServerA-\u0026gt;\u0026gt;ServerA: Server shuts down Note over ServerA: ‚ùå Timer lost! Note over Database: Order stuck in Pending Note over Customer: App shows timeout\u0026lt;br/\u0026gt;but backend is inconsistent What goes wrong: The timer lives only in Server A\u0026rsquo;s memory. When Server A restarts, the timer is gone. Order #12345 never times out.\nNew System: Shared Timeout List sequenceDiagram participant Customer participant ServerA participant SharedList as Shared Timeout List participant Kubernetes participant ServerB participant Database Customer-\u0026gt;\u0026gt;ServerA: Place order ServerA-\u0026gt;\u0026gt;Database: Save order (Pending) ServerA-\u0026gt;\u0026gt;SharedList: Write: Order 12345\u0026lt;br/\u0026gt;timeout at 2:30 PM Note over SharedList: ‚úì Stored safely Kubernetes-\u0026gt;\u0026gt;ServerA: Deploy new version\u0026lt;br/\u0026gt;(restart server) ServerA-\u0026gt;\u0026gt;ServerA: Server shuts down Note over SharedList: ‚úì List still intact! ServerB-\u0026gt;\u0026gt;SharedList: Check for expired timeouts SharedList--\u0026gt;\u0026gt;ServerB: Order 12345 expired ServerB-\u0026gt;\u0026gt;ServerB: Lock and process timeout ServerB-\u0026gt;\u0026gt;Database: Update order (Timeout) ServerB-\u0026gt;\u0026gt;Customer: Notify: Payment timeout ServerB-\u0026gt;\u0026gt;SharedList: Remove Order 12345 What goes right: The timeout information lives in the shared list, not in Server A\u0026rsquo;s memory. When Server A restarts, Server B (still running) finds the expired timeout and processes it. The customer gets the correct notification, and the order status is updated properly.\nTrade-offs and Considerations No solution is perfect. Here\u0026rsquo;s what I gained and what I accepted:\n‚úÖ Benefits Reliability: Timeouts survive server restarts. During deployments, maintenance, or unexpected crashes, no timeout is lost.\nScalability: Works across any number of servers. Adding more servers means more workers checking the list‚Äîbetter throughput.\nConsistency: The system state stays consistent. No more \u0026ldquo;ghost orders\u0026rdquo; that customers think failed but are still active in the backend.\n‚öñÔ∏è Trade-offs Small Processing Delay: Instead of processing timeouts at exactly 60.000 seconds, I process them within ~61 seconds (60 seconds + up to 1 second for the worker to check the list).\nWhy it\u0026rsquo;s acceptable: For a 60-second timeout, a 1-second variance is imperceptible to customers. The business requirement is \u0026ldquo;notify within reasonable time,\u0026rdquo; not \u0026ldquo;exactly at 60 seconds.\u0026rdquo; Dependency on Shared Storage: The system now depends on Redis (the shared storage) being available.\nWhy it\u0026rsquo;s acceptable: Redis is already a critical component for many features (caching, sessions). It\u0026rsquo;s highly reliable with built-in redundancy. If Redis goes down, I have bigger problems than timeouts. Eventual Processing: There\u0026rsquo;s a brief window where a timeout has technically expired but hasn\u0026rsquo;t been processed yet (while waiting for the next worker check).\nWhy it\u0026rsquo;s acceptable: The database check is idempotent‚Äîbefore processing, I verify the order is still in PENDING status. If a payment came through at the last second, I skip the timeout. Real-World Impact After deploying this solution to production:\nMetric Before (In-Memory) After (Shared List) Orders stuck during deployment 5-10 per day 0 Average delay for stuck orders 2-5 minutes N/A Manual cleanup required Daily Never Customer complaints about \u0026ldquo;ghost orders\u0026rdquo; Weekly None Timeout processing accuracy Exact (but fails on restart) Within 1 second (always works) The numbers speak for themselves. The small trade-off (1-second delay) is completely invisible to users, while the benefit (zero stuck orders) dramatically improves both user experience and operational efficiency.\nKey Takeaways This solution teaches us several important principles that apply beyond just timeout handling:\n1. Persistent State Survives Restarts When critical information lives only in application memory, it disappears during restarts. Moving it to external, persistent storage makes it durable.\nApplies to: Background jobs, scheduled tasks, workflow state, temporary data that users depend on.\n2. Shared Storage Enables Distributed Work When multiple servers can see the same work queue, they can share the load and provide redundancy. If one fails, others pick up the slack.\nApplies to: Task queues, job scheduling, event processing, any work that can be distributed.\n3. Locks Prevent Duplicate Processing In distributed systems where multiple workers process the same queue, coordination (locks) ensures each item is processed exactly once.\nApplies to: Payment processing, notification sending, any operation that shouldn\u0026rsquo;t happen twice.\n4. Small Delays Are Often Acceptable Perfect timing (exactly 60.000 seconds) often isn\u0026rsquo;t necessary. \u0026ldquo;Close enough\u0026rdquo; (60-61 seconds) is usually fine if it makes the system more reliable.\nApplies to: Most user-facing features prioritize reliability over microsecond precision.\n5. Idempotency Handles Edge Cases By checking current state before acting (\u0026quot;Is the order still pending?\u0026quot;), the system gracefully handles race conditions and ensures consistency even if something processes twice.\nApplies to: Any distributed operation, retry logic, eventual consistency scenarios.\nConclusion The journey from in-memory timers to shared timeout lists teaches a broader lesson: in distributed systems, shared persistent state is more reliable than isolated in-memory state.\nWhile the old approach (spawn a thread, sleep, execute callback) is simpler to code, it breaks down under real-world conditions: deployments, restarts, scaling up or down. The new approach requires more infrastructure (Redis, workers, locks) but handles these conditions gracefully.\nFor systems running in production‚Äîespecially in containerized environments like Kubernetes where restarts are routine‚Äîthis architectural pattern is essential. Whether you\u0026rsquo;re building e-commerce, ride-sharing, job scheduling, or any system with time-dependent logic, the same principles apply:\nPersist critical state outside your application Distribute the work across multiple workers Coordinate with locks to prevent duplicates Accept small delays for much better reliability The result is a system that works consistently, even when individual servers come and go‚Äîwhich is exactly what modern cloud infrastructure demands.\n","date":"2026-01-10T02:30:00Z","permalink":"https://quanghugo.pages.dev/p/rolling-production-p2/","title":"The Status Order Fail During Rolling Deployments - PART2"},{"content":"The Problem Systems that rely on in-memory timeout mechanisms can encounter critical issues during rolling deployments. When a deployment occurs while timeout operations are in progress, these operations may be terminated before completion, leading to state inconsistencies and system failures.\nConsider, for example, an e-commerce order processing system. When a customer places an order, the system attempts to process their payment confirmation. The system enforces a strict 60-second timeout window to receive payment confirmation. If payment confirmation is not received within this timeframe, the system should automatically return a \u0026ldquo;Payment Timeout\u0026rdquo; response and update the order status accordingly.\nUnder normal operating conditions, this mechanism works perfectly. However, during rolling deployments, some orders may exceed their timeout limits by 2-3x, creating a dangerous inconsistency between what the client displayed and the actual backend state. Orders that should have timed out after 60 seconds may remain in a PENDING_PAYMENT status for 120-180 seconds, causing inconsistent system behavior and user confusion.\nUnderstanding the System Architecture Virtual Threads Overview Many systems leverage Java Virtual Threads (introduced in Java 19 as a preview and finalized in Java 21) to handle timeout mechanisms efficiently. Virtual threads are lightweight threads managed by the Java Virtual Machine, allowing applications to create millions of threads without the overhead of traditional platform threads.\nFor timeout implementations, systems typically spawn a virtual thread that sleeps for the duration of the timeout period (e.g., 60 seconds). When the timeout expires, the thread executes a callback function that handles the timeout scenario.\nThe Timeout Mechanism To illustrate this, let\u0026rsquo;s examine an e-commerce order processing system. In such a system, the timeout flow works as follows:\nOrder Creation: When a customer places an order, the system creates an order record with status PENDING_PAYMENT Timer Initialization: A virtual thread is spawned to handle the timeout countdown Payment Processing: The system attempts to process and confirm the payment Success Path: If payment is confirmed, the timer thread is interrupted and the order status is updated to CONFIRMED Timeout Path: If payment confirmation is not received within 60 seconds, the timer thread executes the timeout callback, updating the order status to PAYMENT_TIMEOUT This design works reliably in stable environments, but reveals a critical flaw during deployment scenarios.\nThe Deployment Failure Scenario During a rolling deployment in Kubernetes, systems using in-memory timeout mechanisms can experience failures. Consider a scenario where an e-commerce system is processing orders during a deployment. The following sequence of events occurs:\nsequenceDiagram participant User as Customer participant Pod as Service Pod participant K8s as Kubernetes participant DB as Database User-\u0026gt;\u0026gt;Pod: Place order request Pod-\u0026gt;\u0026gt;DB: Create order (PENDING_PAYMENT) Pod-\u0026gt;\u0026gt;Pod: Spawn virtual thread\u0026lt;br/\u0026gt;sleep(60s) ‚Üí timeout callback Note over Pod: Timer counting: 59s, 58s, 57s... K8s-\u0026gt;\u0026gt;Pod: SIGTERM signal Pod-\u0026gt;\u0026gt;Pod: JVM shutdown initiated Pod-\u0026gt;\u0026gt;Pod: All threads terminated Note over Pod: Timeout thread killed\u0026lt;br/\u0026gt;before callback executes Pod-\u0026gt;\u0026gt;DB: Pod terminates Note over DB: Order remains in PENDING_PAYMENT state Note over User: Client shows timeout\u0026lt;br/\u0026gt;Backend still waiting What Happens During Rolling Deployment In an e-commerce system, this failure scenario unfolds as follows:\nNormal Operation: An order is created and a virtual thread starts the 60-second countdown Deployment Triggered: Kubernetes initiates a rolling deployment, sending a SIGTERM signal to the pod JVM Shutdown: The Java Virtual Machine begins its shutdown sequence Thread Termination: All threads, including the timeout virtual thread, are terminated immediately Callback Never Executes: The timeout callback that should update the order status never fires State Inconsistency: The order remains in PENDING_PAYMENT status indefinitely, while the client has already shown a timeout error Code Example An example implementation in an e-commerce system might look like this:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 public void createOrder(OrderRequest request) { // Create order in database Order order = orderRepository.save(new Order(request, Status.PENDING_PAYMENT)); // Spawn virtual thread for timeout Thread.ofVirtual().start(() -\u0026gt; { try { Thread.sleep(60_000); // 60 seconds handlePaymentTimeout(order.getId()); } catch (InterruptedException e) { // Payment confirmed, timer interrupted - this is the happy path Thread.currentThread().interrupt(); } }); // Attempt to process payment processPaymentConfirmation(order.getId()); } private void handlePaymentTimeout(Long orderId) { // This callback never executes if pod is killed during deployment orderRepository.updateStatus(orderId, Status.PAYMENT_TIMEOUT); } The critical issue is that handlePaymentTimeout() never executes if the JVM is terminated before the 60-second sleep completes. This problem is not unique to e-commerce systems‚Äîany system relying on in-memory timeout mechanisms faces the same risk.\nWhy This Is Dangerous This failure mode creates a dangerous inconsistency between client and server states. For instance, in an e-commerce system, this might manifest as:\nClient View Backend Reality Shows \u0026ldquo;Order failed\u0026rdquo; or timeout error Order still in PENDING_PAYMENT status User creates a new order Original order still active in database User assumes order failed System still waiting for payment confirmation Payment confirmed late (after timeout) Conflict: order already considered failed by client Real-World Impact This inconsistency leads to several critical problems across different system types. As an example, in an e-commerce system:\nGhost Orders: Orders that appear failed to users but remain active in the system Double Payment Processing: A payment might be confirmed for an order that the user believes has already failed, leading to confusion Data Integrity Issues: The system state becomes inconsistent, making it difficult to track actual order status User Trust Erosion: Users experience unreliable behavior, damaging confidence in the platform Debugging Complexity: Production issues become difficult to trace because the failure is silent and state-dependent Similar issues can occur in any system that relies on in-memory timeout mechanisms‚Äîride-sharing platforms, job scheduling systems, booking systems, and more all face the same fundamental risk.\nRoot Cause Analysis The fundamental problem is architectural: systems that rely entirely on in-memory timeout mechanisms lack persistence or recovery strategy.\nKey Issues No State Persistence: The timeout state exists only in memory. When the JVM terminates, this state is lost forever.\nNo Graceful Shutdown Handling: Applications don\u0026rsquo;t handle shutdown signals to complete pending timeout operations before termination.\nNo Recovery Mechanism: There\u0026rsquo;s no background process to detect and recover operations that should have timed out but didn\u0026rsquo;t. In an e-commerce system, for example, orders that should have timed out remain in an intermediate state.\nTight Coupling: The timeout logic is tightly coupled to the application lifecycle. When the application dies, the timeout dies with it.\nWhy Virtual Threads Don\u0026rsquo;t Help Here While virtual threads are excellent for handling many concurrent operations efficiently, they don\u0026rsquo;t solve the fundamental problem of persistence. Virtual threads are still in-memory constructs that disappear when the JVM terminates. The solution requires moving the timeout mechanism outside of the application\u0026rsquo;s memory space.\nThe Solution: Persistent Timeout Mechanism In our next article, we\u0026rsquo;ll explore how to solve this problem by implementing a persistent timeout mechanism using Redis Sorted Sets (ZSET) combined with a recovery worker pattern.\nThis approach ensures that:\nTimeout state is persisted outside the application memory Timeouts survive pod restarts and deployments A dedicated worker process can recover and process missed timeouts Systems maintain consistency even during infrastructure changes The solution leverages Redis ZSET\u0026rsquo;s ability to store timeout timestamps as scores, allowing efficient querying of expired timeouts, while a background worker continuously processes these timeouts regardless of which pod originally created them. This pattern applies to e-commerce systems, ride-sharing platforms, job schedulers, and any other system requiring reliable timeout handling.\nStay tuned for the detailed implementation in the next post!\n","date":"2025-12-30T00:00:00Z","permalink":"https://quanghugo.pages.dev/p/rolling-production-p1/","title":"The Status Order Fail During Rolling Deployments - PART1"},{"content":"Welcome to my new blog about technical exploration! Here, I will share my learning journey about the tech world around us. Whether you\u0026rsquo;re a seasoned developer or just starting out, I hope this space becomes a valuable resource for learning, inspiration, and technical discussions.\nWhat I\u0026rsquo;ll do at Wang-tech Learning process: I\u0026rsquo;ll document my journey of mastering new technologies, frameworks, and programming languages. This includes tutorials, step-by-step guides, common pitfalls I encounter, and how I overcome challenges. Expect detailed explanations, code examples, and practical tips that you can apply to your own projects.\nNew Technology: I\u0026rsquo;ll explore cutting-edge technologies, tools, and trends in the software development world. From AI and machine learning to cloud computing, microservices architecture, and modern web frameworks - I\u0026rsquo;ll dive deep into what makes these technologies exciting and how they can be leveraged in real-world applications.\nMy tech-life: Beyond just technical content, I\u0026rsquo;ll share insights from my daily life as a developer. This includes project experiences, lessons learned from building applications, code reviews, debugging adventures, and reflections on best practices. You\u0026rsquo;ll get a glimpse into the real-world challenges and triumphs of software development.\nWhat\u0026rsquo;s next As I embark on this blogging journey, I\u0026rsquo;m excited to share my upcoming adventures:\nProject walkthroughs: Real-world applications from concept to deployment Tech stack comparisons: When to use what technology and why Problem-solving sessions: Breaking down complex technical challenges Industry insights: Trends, best practices, and lessons from the field Community engagement: Discussions, Q\u0026amp;As, and collaborative learning I\u0026rsquo;m looking forward to connecting with fellow developers and tech enthusiasts. Your feedback and suggestions will help shape the direction of this blog. Together, we can build a community that thrives on knowledge sharing and continuous improvement.\nThank you for joining me on this journey. Let\u0026rsquo;s explore the fascinating world of technology together!\n","date":"2025-12-29T00:00:00Z","permalink":"https://quanghugo.pages.dev/p/hello-world/","title":"Hello World"},{"content":"This article offers a sample of basic Markdown syntax that can be used in Hugo content files, also it shows whether basic HTML elements are decorated with CSS in a Hugo theme.\nHeadings The following HTML \u0026lt;h1\u0026gt;‚Äî\u0026lt;h6\u0026gt; elements represent six levels of section headings. \u0026lt;h1\u0026gt; is the highest section level while \u0026lt;h6\u0026gt; is the lowest.\nH1 H2 H3 H4 H5 H6 Paragraph Xerum, quo qui aut unt expliquam qui dolut labo. Aque venitatiusda cum, voluptionse latur sitiae dolessi aut parist aut dollo enim qui voluptate ma dolestendit peritin re plis aut quas inctum laceat est volestemque commosa as cus endigna tectur, offic to cor sequas etum rerum idem sintibus eiur? Quianimin porecus evelectur, cum que nis nust voloribus ratem aut omnimi, sitatur? Quiatem. Nam, omnis sum am facea corem alique molestrunt et eos evelece arcillit ut aut eos eos nus, sin conecerem erum fuga. Ri oditatquam, ad quibus unda veliamenimin cusam et facea ipsamus es exerum sitate dolores editium rerore eost, temped molorro ratiae volorro te reribus dolorer sperchicium faceata tiustia prat.\nItatur? Quiatae cullecum rem ent aut odis in re eossequodi nonsequ idebis ne sapicia is sinveli squiatum, core et que aut hariosam ex eat.\nBlockquotes The blockquote element represents content that is quoted from another source, optionally with a citation which must be within a footer or cite element, and optionally with in-line changes such as annotations and abbreviations.\nBlockquote without attribution Tiam, ad mint andaepu dandae nostion secatur sequo quae. Note that you can use Markdown syntax within a blockquote.\nBlockquote with attribution Don\u0026rsquo;t communicate by sharing memory, share memory by communicating.\n‚Äî Rob Pike1\nTables Tables aren\u0026rsquo;t part of the core Markdown spec, but Hugo supports supports them out-of-the-box.\nName Age Bob 27 Alice 23 Inline Markdown within tables Italics Bold Code italics bold code A B C D E F Lorem ipsum dolor sit amet, consectetur adipiscing elit. Phasellus ultricies, sapien non euismod aliquam, dui ligula tincidunt odio, at accumsan nulla sapien eget ex. Proin eleifend dictum ipsum, non euismod ipsum pulvinar et. Vivamus sollicitudin, quam in pulvinar aliquam, metus elit pretium purus Proin sit amet velit nec enim imperdiet vehicula. Ut bibendum vestibulum quam, eu egestas turpis gravida nec Sed scelerisque nec turpis vel viverra. Vivamus vitae pretium sapien Code Blocks Code block with backticks 1 2 3 4 5 6 7 8 9 10 \u0026lt;!DOCTYPE html\u0026gt; \u0026lt;html lang=\u0026#34;en\u0026#34;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026#34;utf-8\u0026#34; /\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Code block indented with four spaces \u0026lt;!doctype html\u0026gt; \u0026lt;html lang=\u0026quot;en\u0026quot;\u0026gt; \u0026lt;head\u0026gt; \u0026lt;meta charset=\u0026quot;utf-8\u0026quot;\u0026gt; \u0026lt;title\u0026gt;Example HTML5 Document\u0026lt;/title\u0026gt; \u0026lt;/head\u0026gt; \u0026lt;body\u0026gt; \u0026lt;p\u0026gt;Test\u0026lt;/p\u0026gt; \u0026lt;/body\u0026gt; \u0026lt;/html\u0026gt; Diff code block 1 2 3 4 5 [dependencies.bevy] git = \u0026#34;https://github.com/bevyengine/bevy\u0026#34; rev = \u0026#34;11f52b8c72fc3a568e8bb4a4cd1f3eb025ac2e13\u0026#34; - features = [\u0026#34;dynamic\u0026#34;] + features = [\u0026#34;jpeg\u0026#34;, \u0026#34;dynamic\u0026#34;] One line code block 1 \u0026lt;p\u0026gt;A paragraph\u0026lt;/p\u0026gt; List Types Ordered List First item Second item Third item Unordered List List item Another item And another item Nested list Fruit Apple Orange Banana Dairy Milk Cheese Other Elements ‚Äî abbr, sub, sup, kbd, mark GIF is a bitmap image format.\nH2O\nXn + Yn = Zn\nPress CTRL + ALT + Delete to end the session.\nMost salamanders are nocturnal, and hunt for insects, worms, and other small creatures.\nThe above quote is excerpted from Rob Pike\u0026rsquo;s talk during Gopherfest, November 18, 2015.\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2025-09-07T00:00:00Z","permalink":"https://quanghugo.pages.dev/p/markdown-syntax-guide/","title":"Markdown Syntax Guide"},{"content":"Hugo supports the creation of interactive image galleries using Markdown. It\u0026rsquo;s powered by PhotoSwipe and its syntax was inspired by Typlog.\nTo use this feature, the image must be in the same directory as the Markdown file, as it uses Hugo\u0026rsquo;s page bundle feature to read the dimensions of the image. External images are not supported.\nSyntax 1 ![Image 1](1.jpg) ![Image 2](2.jpg) Result Photo by mymind and Luke Chesser on Unsplash\n","date":"2025-08-26T00:00:00Z","image":"https://quanghugo.pages.dev/p/image-gallery/2_hu_5b8da187865385db.jpg","permalink":"https://quanghugo.pages.dev/p/image-gallery/","title":"Image gallery"},{"content":"For more details, check out the documentation.\nBilibili video Tencent video YouTube video Generic video file Your browser doesn't support HTML5 video. Here is a link to the video instead. Gist GitLab Quote Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua. Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.\n‚Äï A famous person, The book they wrote Photo by Codioful on Unsplash\n","date":"2025-08-25T00:00:00Z","image":"https://quanghugo.pages.dev/p/shortcodes/cover_hu_4b8e0b1c00bd9fd1.jpg","permalink":"https://quanghugo.pages.dev/p/shortcodes/","title":"Shortcodes"},{"content":"Stack has built-in support for math typesetting using KaTeX.\nIt\u0026rsquo;s not enabled by default side-wide, but you can enable it for individual posts by adding math: true to the front matter. Or you can enable it side-wide by adding math = true to the params.article section in config.toml.\nInline math This is an inline mathematical expression: $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887‚Ä¶$\n1 $\\varphi = \\dfrac{1+\\sqrt5}{2}= 1.6180339887‚Ä¶$ Block math $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ 1 2 3 $$ \\varphi = 1+\\frac{1} {1+\\frac{1} {1+\\frac{1} {1+\\cdots} } } $$ $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ 1 2 3 $$ f(x) = \\int_{-\\infty}^\\infty\\hat f(\\xi)\\,e^{2 \\pi i \\xi x}\\,d\\xi $$ ","date":"2025-08-24T00:00:00Z","permalink":"https://quanghugo.pages.dev/p/math-typesetting/","title":"Math Typesetting"}]